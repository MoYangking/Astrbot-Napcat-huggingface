worker_processes auto;
pid /home/user/nginx/nginx.pid;
error_log /dev/stderr info;

# Load dynamic modules explicitly (custom -c path)
# NDK must be loaded before lua-nginx-module
load_module /usr/lib/nginx/modules/ndk_http_module.so;
load_module /usr/lib/nginx/modules/ngx_http_lua_module.so;

# Pass admin token to workers if set
env ROUTE_ADMIN_TOKEN;

events { worker_connections 1024; }

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    charset utf-8;

    sendfile on;
    keepalive_timeout 65;
    access_log /dev/stdout;

    # Non-root temp directories
    client_body_temp_path /home/user/nginx/tmp/body 1 2;
    proxy_temp_path       /home/user/nginx/tmp/proxy 1 2;
    fastcgi_temp_path     /home/user/nginx/tmp/fastcgi 1 2;
    uwsgi_temp_path       /home/user/nginx/tmp/uwsgi 1 2;
    scgi_temp_path        /home/user/nginx/tmp/scgi 1 2;

    # Shared in-memory route table
    lua_shared_dict route_dict 1m;

    # Initialize defaults on master start
    init_by_lua_block {
        local dict = ngx.shared.route_dict
        if not dict:get("default_backend") then
            dict:set("default_backend", "http://127.0.0.1:6185")
        end
        -- Example rule: if Referer contains 'webui' -> 6099
        if not dict:get("webui") then
            dict:set("webui", "http://127.0.0.1:6099")
        end
    }

    # WebSocket
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # Prefer original client-facing headers
    map $http_x_forwarded_proto $forwarded_proto { default $http_x_forwarded_proto; '' $scheme; }
    map $http_x_forwarded_host  $forwarded_host  { default $http_x_forwarded_host;  '' $host;   }
    map $http_x_forwarded_port  $forwarded_port  { default $http_x_forwarded_port;  '' 443;     }

    server {
        listen 7860;
        server_name _;

        absolute_redirect off;
        port_in_redirect  off;

        # Variable used by Lua to feed proxy_pass
        set $dynamic_backend "";

        # /webui redirect without trailing slash
        location = /webui {
            return 301 /webui/;
        }

        # /webui/* proxies to 6099 (static)
        location ^~ /webui/ {
            proxy_http_version 1.1;
            proxy_set_header Host              $forwarded_host;
            proxy_set_header X-Forwarded-Host  $forwarded_host;
            proxy_set_header X-Forwarded-Prefix /webui;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $forwarded_proto;
            proxy_set_header X-Forwarded-Port  $forwarded_port;
            proxy_set_header Upgrade           $http_upgrade;
            proxy_set_header Connection        $connection_upgrade;
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;

            proxy_pass http://127.0.0.1:6099;
        }

        # /napcat -> /webui
        location = /napcat { return 301 /webui/; }
        location ^~ /napcat/ {
            rewrite ^/napcat/(.*)$ /webui/$1 permanent;
        }

        # Static web UI to manage dynamic routes
        # Served at /admin/ui/ (not the API)
        location ^~ /admin/ui/ {
            alias /home/user/nginx/route-admin/;
            index index.html;
            add_header Cache-Control "no-store";
        }

        # Admin endpoint to manage dynamic routes at runtime
        # - GET  /admin/routes             -> list routes
        # - POST /admin/routes             -> set/delete routes
        #   form fields:
        #     default=http://host:port           (set default backend)
        #     pattern=SUBSTR&backend=http://...  (add/update rule)
        #     op=delete&pattern=SUBSTR           (delete rule)
        # - Authorization: header X-Route-Token must match ROUTE_ADMIN_TOKEN if set
        location = /admin/routes {
            client_max_body_size 1m;
            content_by_lua_block {
                local function unauthorized()
                    ngx.status = 403
                    ngx.say("forbidden")
                    return ngx.exit(403)
                end

                local required = os.getenv("ROUTE_ADMIN_TOKEN") or ""
                if required ~= "" then
                    local hdr = ngx.req.get_headers()["X-Route-Token"]
                    if hdr ~= required then
                        return unauthorized()
                    end
                end

                local dict = ngx.shared.route_dict
                local method = ngx.req.get_method()

                if method == "GET" then
                    ngx.header["Content-Type"] = "text/plain; charset=utf-8"
                    local def = dict:get("default_backend") or ""
                    ngx.say("default_backend=", def)
                    local keys = dict:get_keys(1024)
                    table.sort(keys)
                    for _, k in ipairs(keys) do
                        if k ~= "default_backend" then
                            local v = dict:get(k)
                            if v then ngx.say("rule: pattern=", k, ", backend=", v) end
                        end
                    end
                    return
                end

                if method == "POST" then
                    ngx.req.read_body()
                    local args, err = ngx.req.get_post_args()
                    if not args then
                        ngx.status = 400
                        ngx.say("bad request: ", err or "no args")
                        return
                    end

                    -- set default
                    if args["default"] and args["default"] ~= "" then
                        dict:set("default_backend", args["default"])
                        ngx.say("ok: default set to ", args["default"])
                        return
                    end

                    local op = args["op"] or "set"
                    local pat = args["pattern"]
                    if not pat or pat == "" then
                        ngx.status = 400
                        ngx.say("bad request: missing pattern")
                        return
                    end

                    if op == "delete" then
                        dict:delete(pat)
                        ngx.say("ok: deleted ", pat)
                        return
                    end

                    local backend = args["backend"]
                    if not backend or backend == "" then
                        ngx.status = 400
                        ngx.say("bad request: missing backend")
                        return
                    end
                    dict:set(pat, backend)
                    ngx.say("ok: set ", pat, " -> ", backend)
                    return
                end

                ngx.header["Allow"] = "GET, POST"
                return ngx.exit(405)
            }
        }

        # /api/* dynamic routing via Lua using Referer substring rules
        location ^~ /api/ {
            # choose backend based on shared dict
            access_by_lua_block {
                local dict = ngx.shared.route_dict
                local referer = ngx.var.http_referer or ""
                local chosen = dict:get("default_backend") or "http://127.0.0.1:6185"
                local keys = dict:get_keys(1024)
                -- Try longer patterns first (more specific)
                table.sort(keys, function(a,b) return #a > #b end)
                for _, k in ipairs(keys) do
                    if k ~= "default_backend" then
                        if referer:find(k, 1, true) then
                            local v = dict:get(k)
                            if v and v ~= "" then
                                chosen = v
                                break
                            end
                        end
                    end
                end
                ngx.var.dynamic_backend = chosen
            }

            proxy_http_version 1.1;
            proxy_set_header Host              $forwarded_host;
            proxy_set_header X-Forwarded-Host  $forwarded_host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $forwarded_proto;
            proxy_set_header X-Forwarded-Port  $forwarded_port;
            proxy_set_header Upgrade           $http_upgrade;
            proxy_set_header Connection        $connection_upgrade;
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;

            proxy_pass $dynamic_backend;
        }

        # Root proxies to 6185 (SPA/hashes)
        location / {
            proxy_http_version 1.1;
            proxy_set_header Host              $forwarded_host;
            proxy_set_header X-Forwarded-Host  $forwarded_host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $forwarded_proto;
            proxy_set_header X-Forwarded-Port  $forwarded_port;
            proxy_set_header Upgrade           $http_upgrade;
            proxy_set_header Connection        $connection_upgrade;
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;

            proxy_pass http://127.0.0.1:6185;
        }
    }
}
